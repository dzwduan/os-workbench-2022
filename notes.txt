


Lec17:
elf的结构描述了进程在execve中如何运行







Lec23:
core dump：内存crash后将内存dump到外部存储
ulimit 修改 core file size
sram/dram:   dram也是行信号+列信号+电容，类似磁芯存储
状态机发生crash会导致reg mem部分丢失，但是持久存储部分还在

现代磁盘上自带cpu+soc+dram，soc可以更好地管理磁盘，只需要将请求发给磁盘，磁盘内部会自动调度, 电梯调度算法已被淘汰
cat /sys/block/sda/queue/scheduler

软盘里面实际是一个磁片，容量低+可靠性低，被淘汰

光盘实际上里面都是坑，唯一缺点写入慢
光刻，射镜

总结：

磁： 机械部件导致ms级延迟
坑(光)：挖坑容易填坑难
电路是目前最优:根据电子状态分0/1


SSD : ssd tlc
Flash Memory 几乎没有缺点 , 容量越大速度越快，nvme几乎淘汰旧的sata接口，缺点是充放电次数过多会失效
解决方案：每个ssd里面都有完整的计算机系统,有类似虚拟内存的机制; wear leveling 软件管理可能出问题的blocks
磁盘恢复：logic block损坏但是physical block数据还存在; 安全需要文件系统加密






Lec24
I/O设备：一个能与cpu交换数据的接口/控制器, 状态+命令+数据
设备驱动程序：相当大头的代码，bug非常多
键盘也是可以编程控制的，只有两个寄存器 8042 p/s 2
磁盘控制器ATA IDE接口磁盘 也是通过寄存器操作
I/O设备通过fpga verilog很容易实现
打印机比较复杂，计算机图形学鼻祖之一，postScript描述页面布局的编程语言

总线，直连cpu，可以桥接其他总线，今天使用pcie 总线
PIC APIC连接中断源, 8259可以级联产生更多接口
当前的cpu有local APIC和 I/O APIC.
local APIC: 中断向量表 IPI  时钟

中断没能解决的问题: 写入大量数据到磁盘，一直使用中断太占CPU处理时间，因此产生DMA，一个专门执行memcpy程序的CPU Intel 8237a, 多用于网卡
DMA本质是做一件特别事情的cpu,还有其他做特别事情的cpu，如显卡只画图
最早的显卡, NES picture Processing Unit (PPU)
实现3D: 任何n边形都可分解为n-2个三角形
现代GPU: 完整的众核多处理器，例如4096个cpu






Lec25
设备实际上是一组寄存器 + 协议，设备驱动程序的本质是抽象一个统一的device访问接口
I/O设备最重要的功能：input output

字符设备：字节流，键盘鼠标
块设备：字节数组，磁盘，
显卡是什么设备？显存是字节数组但不是按块访问，但是控制通过字节流

三大抽象：
read
write
ioctl- 读取/设置设备的状态


设备驱动程序：为该抽象模型建立的代码
最简单的设备驱动 /dev/null ,  收到写请求直接丢掉, 读请求直接返回0
cat /dev/zero | head -c 128 | xxd  查看读取的内容
tty是终端设备


设备驱动: Linux内核中最多+质量最低的代码
字节流抽象的缺点： 所有额外功能全部依靠ioctl, ioctl大概1000万行代码相关

终端的例子: 
python3 -m rich
stty -a
isatty(3) 判断当前输入是否是终端, 使用了fstat
termios(3)
ftrace 会发现很多ioctl

everything is file

unlocked_ioctl 无锁
compat_ioctl   兼容性

如何为GPU编程？
取指 -> 译码 -> 执行(x10000) ，前两部分的电路省下来，从而能跑的更快
所有的cpu共用一个pc指针,执行同一条指令，SIMT

磁盘策略：读优先更好，